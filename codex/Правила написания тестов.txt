Юнит тесты - это тесты, которые тестируют поведение приложения в изоляции от других систем (например посредствам моков). Если тест работает с БД, файловой системой, внешним API напрямую - то это интеграционный тест. (если мы мокируем внешний сервис, то это юнит тест, т.к. мы на самом деле не тестируем взаимодействие с реальным внешним сервисом) 


Нижеописанные правила - не абсолютны. Если у тебя есть good reason их нарушить, то нарушай. Эти правила не должны стать для тебя поводом переусложнить код. Если ты хочешь изменить код под тесты (totally feasable ситуация), то сначала проконсультируйся со мной!
* Пиши только юнит-тесты, которые покрывают единицу поведения (units of behavior), а не единицы кода (классы или методы). Количество классов, задействованных в одной единице поведения, не важно. Это означает, что не нужно стремиться к полной изоляции класса посредствам моков.

* Используй строгую структуру AAA: arrange (подготовка), act (действие), assert (проверка); не допускай множественных блоков одного типа и ветвлений (if) внутри теста.

* В секции act должен быть один вызов, почти всегда одна строка. Если требуется больше — вероятно, проблема в API.

Не тестируй приватные методы; В тесте мы вообще не должны задумываться ни о каких приватных методах. Приватные методы - это business системы, которую тестим. Не раскрывай приватные поля ради тестов.

Не используй жёсткие шаблоны для нейминга; называй тест как факт о поведении (на человеческом, желательно бизнес-языке), без упоминания названия метода. Избегай cryptic names.

Для параметрических тестов объединяй однотипные случаи — но не жертвуй читаемостью.

Всегда уменьшай зависимость тестов от деталей реализации (минимизируй ложные срабатывания при рефакторинге — resistance to refactoring).

Избегай анти-паттернов: code pollution (добавление кода в production только ради тестов), тестинг приватных методов, утечку доменных деталей, чрезмерное использование моков.

Предпочитай output-based тестирование (проверка результата работы), реже — state-based (проверка состояния), моки — только для исходящих взаимодействий (outcoming) с управляемыми зависимостями (managed dependencies). Никогда не проверяй взаимодействие со стабами (stubs) — они нужны только для эмуляции входящих данных.

Мокируй только управляемые зависимости (managed dependencies) — те, которые видны вне приложения и являются частью observable behavior. Не мокируй неуправляемые зависимости (например, БД, доступную только через приложение) — они часть твоего приложения; работай с ними напрямую.

Если тест нельзя привязать к бизнес-требованию, это признак его хрупкости. Исключение: утилитарный код с высокой алгоритмической сложностью.

Тестируй методом black-box (не знаешь внутреннюю реализацию), а не white-box. Это защитит от хрупких тестов.

При работе с библиотеками и out-of-process зависимостями: мокируй последнюю стадию взаимодействия перед выходом из приложения — это обеспечивает обратную совместимость. Если интерфейс библиоки стабилен и понятен — можно мокировать напрямую. Иначе — оберни в wrapper, мокируй wrapper, напиши тесты на wrapper (мокируя библиотеку, если имеет смысл).

Используй spies вместо моков для edge-классов (например, шины сообщений) — они позволяют переиспользовать код в assert-секции и улучшают читаемость через fluent interface.

Не полагайся на production-код при проверках в тестах.

Соблюдай разделение бизнес-логики и оркестровки: код либо общается с out-of-process зависимостями, либо содержит сложную логику, но не оба одновременно (domain model + controllers).

Не тестируй репозитории напрямую, только в составе интеграционных тестов.

Делай границы domain model явными (отдельная сборка или namespace).

Сокращай количество слоёв в приложении. Много слоёв абстракции усложняют понимание, размывают границу между контроллерами и доменом, приводят к low-value интеграционным тестам.

Избегай циклических зависимостей.

Не тестируй тривиальные геттеры/сеттеры и код без бизнес-логики.

Код — это не актив, а нагрузка (liability). Чем больше кода, тем выше риск багов. Это касается и тестового кода. Поэтому старайся делать тесты simple, не усложняя без необходимости
