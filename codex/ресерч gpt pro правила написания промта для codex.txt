Ниже — **практическое, “скопировал‑вставил”** руководство по архитектуре и дизайну системного промпта именно для **OpenAI Codex** (CLI/IDE/Cloud-версия 2025), с примерами файлов и чёткими правилами. Я опираюсь на официальные гайды Codex (Prompting + AGENTS.md), а также на опыт открытых ассистентов (Aider, Continue, Cody), и исследования про расположение информации в длинном контексте. Ссылки вставляю по делу. ([OpenAI Developers][1])

---

## Короткий вывод (tl;dr)

* **Не ссылайся на файлы по путям в самом промпте** — LLM не «прочитает» путь. Либо используй механизмы Codex **AGENTS.md** (глобальные/проектные правила подхватываются автоматически), либо сам **вклеивай содержимое** блоков при сборке промпта. ([OpenAI Developers][2])
* Для максимального соблюдения правил: **жёсткая иерархия приоритетов (R1…Rn)**, **фиксированный формат вывода**, **минимальные, но показательные few‑shot примеры**, **чек‑лист самопроверки** и **стоп‑последовательности** для обрубания лишнего текста. Плюс **“верификация через тесты”** — Codex это прямо рекомендует. ([OpenAI Developers][1])
* Версионируй **правила отдельно** (AGENTS.md по уровням + семвер/хэши), а системный промпт держи «тонким». Часто меняющиеся правила — в ближних к задаче override‑файлах. Codex сам склеит цепочку с приоритетом «ближе к текущей папке важнее». ([OpenAI Developers][2])
* Размер: стремись к **500–900 токенам** на жёсткое ядро + 1–2 коротких примера. Располагай **критичные указания в начале и в конце** — информация в середине длинного контекста усваивается хуже («lost in the middle»). ([arXiv][3])

---

## 1) Модульная архитектура промпта

### Что работает в Codex «из коробки»

* **AGENTS.md** — официальный способ дать Codex устойчивые правила. Он **автоматически** читает:

  1. **глобальный** `~/.codex/AGENTS.md` (или `AGENTS.override.md`),
  2. **проектные** файлы по дереву директорий от корня к текущей папке,
  3. **сливает их по порядку**, где **позднее найденные перекрывают ранние**,
  4. учитывает **лимит размера** (дефолт ~**32 KiB**), который можно поднять. ([OpenAI Developers][2])

> Это ровно решает задачу «модулярности» без самописной сборки: общие правила — глобально, командные/сервисные — ближе к коду; пересечения — через override.

### Схема с «ссылками на файлы» в основном промпте

* Если ты просто напишешь `БЛОК ТЕСТОВ: /rules/tests.md` **без механизма загрузки**, модель не увидит содержимое. Либо:

  * переходи на **AGENTS.md**/override‑ы (рекомендуется для Codex), либо
  * пиши **сборщик**, который **инлайнит** содержимое `/rules/*.md` в итоговый системный промпт (или добавляет их отдельными сообщениями, если ты вызываешь Codex через SDK). ([OpenAI Developers][2])

### Когда всё же нужен свой сборщик

* Если у тебя **нестандартная разметка/генерация** (например, динамическая подстановка версий библиотек, автосаммари тестов, сжатие правил) — имеет смысл собрать «тонкое ядро» + выбранные **модули** (tests, errors, style) в один промпт. Многие открытые ассистенты идут этим путём (см. Aider/Continue/Cody — они оперируют библиотеками готовых промптов и токен‑бюджетированием). ([Aider][4])

---

## 2) Best practices, чтобы модель **строго соблюдала** правила

Ниже — «скелет» и приёмы, которые показали наибольший прирост комплаенса в код‑тасках (в т.ч. рекомендованные самим Codex: ставить явные указания, тесты и шаги верификации).

### A. Структура системного промпта (ядро)

**Порядок важен**: критичное — в **начале** и **в конце** (эффект «lost in the middle»). ([arXiv][3])

````md
# ROLE & MISSION
Ты – инженер-программист, выполняющий задачи в этом репо. Пиши минимальные изменения, поддерживай стиль и тесты.

# PRIORITY ORDER (обязательные правила)
R1. Следуй ФОРМАТУ ВЫВОДА.
R2. Не добавляй пояснений вне кода/диффа.
R3. Соблюдай STYLE & LINT (см. блок ниже).
R4. Обязательно запускай/имитируй тесты по инструкции.
R5. Если правило конфликтует – приоритет у правила с меньшим номером (R1 > R2 > ...).

# OUTPUT FORMAT (жестко)
Выводи ТОЛЬКО один из вариантов:
- Unified diff (git patch) без прелюдий
- ИЛИ: Файловые блоки:
  ```path: relative/file.ext
  <содержимое>
````

Никаких пояснений до/после. Стоп-последовательности: `END_OF_DIFF`, `END_OF_FILE_BLOCKS`.

# STYLE & LINT (кратко)

* Язык/фреймворк: ...
* Форматирование: ...
* Импорты: ...
* Запрещено: ...
* Коммиты: Conventional Commits: <type>(scope): message

# TESTS-AS-SPEC (верификация)

* Запуск: `pnpm test` (или конкретная команда)
* Минимум: все измененные модули должны иметь покрытие >X% и проходить тесты
* Если тесты не описаны — предложи краткий план quick-check (не выводи его, только прими во внимание)

# COMMON ERRORS (типичные сбои и как не делать)

* Не выводить объяснения
* Не менять public API без миграции
* Не добавлять зависимости без подтверждения

# FINAL CHECKLIST (перед выводом)

* [ ] Компилируется без ошибок/варнингов?
* [ ] Есть тест/обновлен тест?
* [ ] Дифф минимален и идемпотентен?
* [ ] Соответствие OUTPUT FORMAT?

````

**Почему это работает**
— Явная **иерархия правил** и **формат вывода** → меньше произвольного текста; **тесты как спецификация** → повышают качество; **повтор ключевых запретов в конце** (R‑правила + чек‑лист) → срабатывает за счёт эффекта края и явных стоп‑слов. :contentReference[oaicite:9]{index=9}

### B. Техники

- **Few‑shot, но коротко.** 1–2 минимальных примера *правильного диффа* или *файловых блоков* повышают точность больше, чем любые рассуждения. Примеры должны быть **структурно** тождественны целевому формату.
- **“Думай скрытно — выводи только результат.”** Проси модель *планировать внутренне*, но запрещай печатать рассуждения. (В Codex достаточно указания в правилах + стоп‑последовательности.)
- **Тесты/воспроизведение багов** как часть задания (steps to reproduce, команды линтера/CI) — это прямой совет из Codex Prompting Guide. :contentReference[oaicite:10]{index=10}
- **Стоп‑последовательности** и **жёсткие маркеры** (`END_OF_DIFF` и т.п.) помогают «обрубить» объяснения. :contentReference[oaicite:11]{index=11}
- **Дублируй критические запреты в конце** (ещё раз R1–R5 + чек‑лист) — из‑за эффекта края это реально помогает. :contentReference[oaicite:12]{index=12}

### C. Где располагать информацию
- Критичные правила (формат, запреты, приоритеты) — **в начале**.
- Тесты/верификация — **в начале** *или* **в конце**; не прячь в середину.
- Примеры — **после правил** (чтобы не «сдвигать» приоритеты) и **перед чек‑листом**.

---

## 3) Версионирование и «живые» правила

- **Отдельно версионируй правила** от системного промпта. В Codex это естественно:
  - глобальные `~/.codex/AGENTS.md`/`AGENTS.override.md` — твои «политики по умолчанию»,
  - проектные `AGENTS.md`/`AGENTS.override.md` — часто меняющиеся нормы рядом с кодом,
  - порядок слияния: ближние к текущей папке **перекрывают** верхнеуровневые. :contentReference[oaicite:13]{index=13}
- Включай **версию/хэш** в заголовок каждого правила‑модуля, чтобы отлаживать регрессии промпта (напр. `R4 tests@2025.11.10#c1a2b3`).
- Для быстрых изменений — используй **override‑файлы** (например, `services/payments/AGENTS.override.md`) и удали их, когда больше не нужны. :contentReference[oaicite:14]{index=14}
- Если у тебя собственный сборщик — применяй **SemVer + CHANGELOG** для набора правил; встраивай `X-Prompt-Version` в шапку промпта и логируй его в CI.

---

## 4) Размер и плотность

- **Ядро (без примеров)** — **500–900 токенов** обычно достаточно для кода: там роль, приоритеты, формат, тесты, чек‑лист.
- **Примеры**: 1–2 коротких (10–30 строк каждый), адаптированных под текущий стек.
- **Где выигрывать в качестве**: добавляй **верификацию** (команды тестов/линтера), а не длинные «правовые трактаты». Это советует и официальный гайд Codex. :contentReference[oaicite:15]{index=15}
- Не забывай про лимит на агрегированные инструкции в Codex (по умолчанию ~**32 KiB** на цепочку AGENTS.md) — крупные правила лучше **делить по папкам**; ближний `override` окажется в конце и перетрёт общее. :contentReference[oaicite:16]{index=16}
- Учти когнитивную особенность моделей: информация **посередине** длинных промптов усваивается хуже — не прячь туда критичные правила. :contentReference[oaicite:17]{index=17}

---

## Готовые «артефакты» (копируй и вставляй)

### A) Проектный `AGENTS.md` (в корне репо)

```md
# AGENTS.md  v1.2.0

## Repository expectations
- Run `pnpm test -w` before proposing a diff.
- Lint: `pnpm lint` (eslint + prettier).
- Use Conventional Commits in PR titles.

## Output contract (MUST)
- Only unified diff (git patch) OR file blocks (see below).
- No extra explanations before/after.
- Stop sequences: END_OF_DIFF, END_OF_FILE_BLOCKS.

## Style
- TS: strict mode, no implicit any, no default export in utils.
- Python: black + isort, type hints for public functions.

## Tests-as-spec
- Jest: `pnpm test -- <pattern>`; Pytest: `pytest -q`.
- Add/adjust tests for changed behavior; ensure ≥ existing coverage.

## Common errors to avoid
- Don’t add new prod dependencies without confirmation.
- Don’t change public API without migration notes.

## Local quick commands
- Install: `pnpm i`
- Dev: `pnpm dev`
- Build: `pnpm build`
````

> При необходимости добавляй **`services/<svc>/AGENTS.override.md`** с локальными правилами — они перекроют общий файл и будут учтены первыми для текущей папки. ([OpenAI Developers][2])

### B) Глобальный `~/.codex/AGENTS.md` (твои «рабочие соглашения»)

````md
# ~/.codex/AGENTS.md  v1.0.0

## Working agreements
- Prefer pnpm over npm when possible.
- Ask for approval before adding prod deps.
- After edits, run tests/linters as defined by project.

## Output format (global)
- Default to unified diff; if not applicable, use file blocks:
```path: <relative/path.ext>
<content>
````

* Forbid explanations. Stop sequences: END_OF_DIFF, END_OF_FILE_BLOCKS.

````

> Codex сам найдёт этот файл и склеит его с проектными правилами; лимит размера регулируется `project_doc_max_bytes` в `~/.codex/config.toml`. :contentReference[oaicite:19]{index=19}

### C) Системный промпт для «ручного запуска»/SDK (тонкое ядро)

```md
# SYSTEM — CodeGen Contract (v1.3.1)

You are a coding assistant operating on this repository. Produce minimal, safe diffs that pass tests and linters.

PRIORITY (highest first):
R1 FORMAT — Follow OUTPUT ONLY.
R2 TESTS — Ensure test commands succeed or propose diff incl. tests.
R3 STYLE — Respect project style & lint rules.
R4 SCOPE — Minimize changes; keep API stable.
R5 SAFETY — No new prod deps without approval.

OUTPUT:
- EITHER a single unified diff (git apply ready), end with `END_OF_DIFF`
- OR one or more file blocks:
  ```path: relative/file.ext
  <content>
````

end with `END_OF_FILE_BLOCKS`
No extra text.

SELF-CHECK before output:

* compiles? tests pass? style ok? minimal diff? output format correct?

(Examples of valid output are provided below.)

```

**Добавь 1–2 коротких примера** валидного диффа или файловых блоков (по твоему стеку) сразу после ядра. Это критично для соблюдения формата.

---

## Примеры «из реальных кодовых ассистентов»

- **OpenAI Codex**: официальный **Prompting Guide** (давай «указатели на код», «шаги верификации»), и **AGENTS.md** (автоматическое обнаружение и слияние правил, override‑ы, лимит размера, настраиваемые fallback‑имена). :contentReference[oaicite:20]{index=20}
- **Aider**: держит системные промпты/настройки отдельно, есть prompt caching и рекомендации не подсовывать в контекст «весь репозиторий», а только релевантные файлы. :contentReference[oaicite:21]{index=21}
- **Continue**: хранит и переиспользует промпты‑шаблоны (md‑файлы, slash‑команды), удобно для модульности и повторного использования. :contentReference[oaicite:22]{index=22}
- **Sourcegraph Cody**: библиотека промптов/команд и сборка «преамбул + контекст + история» с учётом бюджета токенов — хороший ориентир для приоритизации контекста. :contentReference[oaicite:23]{index=23}

---

## Практика: как организовать у тебя

### Вариант 1 (рекомендуется для Codex): AGENTS.md‑цепочка без самописного кода
1) Создай `~/.codex/AGENTS.md` для общих правил (как выше).
2) В корне репо — `AGENTS.md` + при необходимости `*/AGENTS.override.md` в сервисах/пакетах.
3) Если уже есть «свои» названия (например, `TEAM_GUIDE.md`) — добавь их в fallback‑список в `~/.codex/config.toml`.
4) Проверь загрузку командой:
   `codex --ask-for-approval never "Summarize the current instructions."` (Codex выведет источники и применённые правила). :contentReference[oaicite:24]{index=24}

### Вариант 2: Свой сборщик «блоков»
- Директория `rules/` → `core.md`, `output.md`, `style.md`, `tests.md`, `errors.md`.
- Сборщик объединяет модули по **приоритету** в итоговый системный промпт + встраивает **1–2 примера**.
- Ставь **stop‑последовательности** в API‑вызове; держи ядро ≤900 токенов; пример(ы) — максимально похожи на желаемый формат. :contentReference[oaicite:25]{index=25}

---

## Частые вопросы

**Нужно ли писать логику подгрузки файлов в контекст?**
— Если ты на Codex (CLI/IDE/Cloud) — **нет**, лучше полагайся на AGENTS.md (встроено в продукт). Если используешь Codex через SDK и свой пайплайн — **да**, без инлайна содержимого или retrieval’а ссылки бесполезны. :contentReference[oaicite:26]{index=26}

**Где держать часто меняющиеся правила?**
— В `AGENTS.override.md` как можно ближе к месту работы (папка сервиса/пакета). Удалил override — вернулся к общим правилам. :contentReference[oaicite:27]{index=27}

**Что важнее — 60 строк плотного текста или 100 строк с примерами?**
— Для кодогенерации **короткое ядро + 1–2 примера** обычно выигрывает у «плотного эссе» без примеров. Но не уходи в «роман» — следи за бюджетом токенов и эффектом края (ключевое — в начало/конец). :contentReference[oaicite:28]{index=28}

---

## Микротрюки для скорости и стабильности

- **Токены экономим**: держи ядро компактным; переноси «энциклопедию правил» в AGENTS.md (они подхватятся без повторения в каждом запросе). :contentReference[oaicite:29]{index=29}
- **Параметры генерации** (если вызываешь через API): низкая температура/узкий разброс, `stop` для жёсткой отсечки. :contentReference[oaicite:30]{index=30}
- **Автоверификация**: фиксируй команды тестов/линтеров в AGENTS.md — Codex прямо рекомендует включать шаги проверки. :contentReference[oaicite:31]{index=31}

---

## Полезные ориентиры/ресурсы

- **Codex Prompting Guide** (про «указатели на код», «верификацию», «декомпозицию»). :contentReference[oaicite:32]{index=32}
- **Codex + AGENTS.md** (поиск, порядок объединения, overrides, лимиты, fallback‑имена). :contentReference[oaicite:33]{index=33}
- **Aider / Continue / Cody** — открытые ассистенты с модульными промптами и приоритизацией контекста. :contentReference[oaicite:34]{index=34}
- **Исследование «Lost in the Middle»** — почему располагать критичное надо в начале/конце. :contentReference[oaicite:35]{index=35}
- **Stop‑последовательности и контроль длины** (официально). :contentReference[oaicite:36]{index=36}

---

### Если хочешь, я могу сразу собрать тебе «скелет» репозитория с `~/.codex/AGENTS.md`, корневым `AGENTS.md`, парой `AGENTS.override.md` и заготовкой **тонкого системного промпта** — скажи стек (язык/линтер/тест‑раннер) и формат патчей/блоков, и я отдам готовые файлы.
::contentReference[oaicite:37]{index=37}
```

[1]: https://developers.openai.com/codex/prompting "Prompting guide"
[2]: https://developers.openai.com/codex/guides/agents-md "Custom instructions with AGENTS.md"
[3]: https://arxiv.org/abs/2307.03172?utm_source=chatgpt.com "Lost in the Middle: How Language Models Use Long Contexts"
[4]: https://aider.chat/docs/?utm_source=chatgpt.com "Aider Documentation | aider - aider.chat"
